<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - glTF loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #000;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			color: #fff;
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			z-index: 100;
			display: block;
		}

		#info a {
			color: #75ddc1;
			font-weight: bold;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader
		<br /> Battle Damaged Sci-fi Helmet by
		<a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a>
		<br />
	</div>

	<script src="../build/three.js"></script>

	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/loaders/GLTFLoader.js"></script>

	<script src="js/Detector.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script>

		if (!Detector.webgl) Detector.addGetWebGLMessage();

		var container, stats, controls;
		var camera, scene, renderer, light;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var radius = 100, theta = 0;

		init();
		animate();


		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);

			controls = new THREE.OrbitControls(camera);
			controls.target.set(0, -0.2, -0.2);
			controls.update();

			// envmap
			var path = 'textures/cube/skyboxsun25deg/';
			var format = '.jpg';
			var envMap = new THREE.CubeTextureLoader().load([
				path + 'px' + format, path + 'nx' + format,
				path + 'py' + format, path + 'ny' + format,
				path + 'pz' + format, path + 'nz' + format
			]);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xf0f0f0);
			// scene.background = envMap;

			light = new THREE.HemisphereLight(0xbbbbff, 0x444422);
			light.position.set(0, 1, 0);
			scene.add(light);

			light = new THREE.DirectionalLight(0xffffff);
			light.position.set(-10, 6, -10);
			scene.add(light);

			// model
			var loader = new THREE.GLTFLoader();

			loader.load('models/gltf/test/glTF/Test001.gltf', function (gltf) {

				gltf.scene.traverse(function (child) {

					// if (child.isMesh) {

					// 	child.material.envMap = envMap;

					// }

				});
				gltf.scene.scale.set(0.0004, 0.0004, 0.0004);

				//gltf.cameras['Infinite perspective camera'];


				object = gltf.scene;
				object.updateMatrixWorld();
				const box = new THREE.Box3().setFromObject(object);
				const size = box.getSize().length();
				const center = box.getCenter();

				object.position.x += (object.position.x - center.x);
				object.position.y += (object.position.y - center.y);
				object.position.z += (object.position.z - center.z);

				scene.add(gltf.scene);
				// console.log(scene.children[2].children["0"]);
				camera.position.set(10, 10, 10)
				console.log(camera.position);
				console.log(gltf.scene.position);
				// camera.position = object.position;
				// camera.Translate(0, 0, -10); // where `r` is the desired distance
				// camera.lookAt(object.position);



			});

			//				camera.lookAt(scene.position)

			//			    this.clear();

			raycaster = new THREE.Raycaster();

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			container.appendChild(renderer.domElement);

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mousedown', onDocumentMouseDown, false);

			window.addEventListener('resize', onWindowResize, false);

			// stats
			stats = new Stats();
			container.appendChild(stats.dom);

		}

		function onDocumentMouseMove(event) {
			event.preventDefault();

			// mouse.x = ( event.clientX / window.innerWidth) * 2 - 1;
			// mouse.y = ( event.clientY / window.innerHeight) * 2 + 1;
			mouse.x = ((event.clientX - container.offsetLeft + document.body.scrollLeft) / container.offsetWidth) * 2 - 1;
			mouse.y = -((event.clientY - container.offsetTop + document.body.scrollTop) / container.offsetHeight) * 2 + 1;

		}
		function onDocumentMouseDown(event) {
			event.preventDefault();

			// mouse.x = ( event.clientX / window.innerWidth) * 2 - 1;
			// mouse.y = ( event.clientY / window.innerHeight) * 2 + 1;
			// mouse.x = ((event.clientX - container.offsetLeft + document.body.scrollLeft) / container.offsetWidth) * 2 - 1;
			// mouse.y = -((event.clientY - container.offsetTop + document.body.scrollTop) / container.offsetHeight) * 2 + 1;
			
			if(INTERSECTED !== null){
				// INTERSECTED.material.color.setHex(0xff0000);
				INTERSECTED.material.transparent = !INTERSECTED.material.transparent;
				// INTERSECTED.visible = false;	
				console.log(INTERSECTED.visible);
			}
			
			
		}



		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			// renderer.render(scene, camera);
			render()
			stats.update();

		}

		function render() {

			raycaster.setFromCamera(mouse, camera);
			if (scene.children[2] == null) {
				// console.log(scene.children[2]);
				return;
			}
			var intersects = raycaster.intersectObjects(scene.children[2].children[0].children);
			if (intersects.length > 0) {
				if (INTERSECTED != intersects[0].object) {
					if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
					INTERSECTED = intersects[0].object;
					INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
					INTERSECTED.material.emissive.setHex(0xff0000);
					console.log(INTERSECTED);
				}
			} else {
				if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
				INTERSECTED = null;
			}
			renderer.render(scene, camera);
		}

	</script>

</body>

</html>